#!/usr/bin/env python

import sys, os
from fractions import gcd

import numpy
from numpy import concatenate

import networkx as nx

from solve import get_reductor, array2, row_reduce, dot2, shortstr, zeros2, shortstrx, eq2
from solve import u_inverse, find_kernel, find_logops, identity2, solve
from solve import check_conjugate, check_commute
from isomorph import write

import models
from models import genidx

import gauge

"""
Find the closure of the gauge operators under bracket.
"""

import cbracket
cbracket = cbracket.bracket

def bracket(a, b):
    #return cbracket(a.tostring(), b.tostring())
    c1 = cbracket(a.tostring(), b.tostring())
    a, b = a.copy(), b.copy()
    assert len(a)==len(b)
    assert len(a)%2==0
    n = len(a)//2
    a.shape = (n, 2)
    b.shape = (n, 2)
    #print a
    #print b
    b = b[:, [1, 0]]
    #print b
    c = a*b
    c = c.sum() % 2
    assert c==c1
    return c


def is_zop(a):
    a = a.copy()
    a.shape = (len(a)//2, 2)
    assert a.sum()
    return a[:, 0].sum() == 0


def get_xop(a):
    a = a.copy()
    a.shape = (len(a)//2, 2)
    assert a[:, 1].sum()==0
    a = a[:, 0]
    a.shape = (len(a),)
    return a

def get_zop(a):
    a = a.copy()
    a.shape = (len(a)//2, 2)
    assert a[:, 0].sum()==0
    a = a[:, 1]
    a.shape = (len(a),)
    return a


def mkop(xop, zop):
    if xop is None:
        xop = zeros2(len(zop))
    if zop is None:
        zop = zeros2(len(xop))
    xop, zop = xop.view(), zop.view()
    n = len(xop)
    xop.shape = 1,n
    zop.shape = 1,n
    op = numpy.concatenate((xop, zop))
    op = op.transpose().copy()
    op.shape = (2*n,)
    return op


#def closure(gen):
#    "take closure under bracket operation (up to factor of 2)"
#    ops = list(gen)
#    found = set(op.tostring() for op in ops)
#    new = ops
#    while 1:
#        _new = []
#        N = len(ops)
#        count = 0
#        for a in ops:
#          _a = a.tostring()
#          count += 1
#          #if (count*256/N)%16==0:
#          #write("&")
#          for b in new:
#            #if bracket(a, b):
#            if cbracket(_a, b.tostring()):
#                c = (a+b)%2
#                s = c.tostring()
#                if s not in found:
#                    found.add(s)
#                    _new.append(c)
#                    if len(found)%256==1:
#                        write(len(found))
#        if not _new:
#            break
#        ops.extend(_new)
#        new = _new
#        if argv.verbose:
#            print "/ ----- /", len(ops)
#            sys.stdout.flush()
##    if argv.verbose:
##        print ;sys.stdout.flush()
#    return ops


def find_ideal(gen, ops=None):
    "find ideal generated by gen, inside lie algebra generated by ops"
    if ops is None:
        ops = list(gen)
    gen = list(gen)
    found = set(op.tostring() for op in gen)
    while 1:
        new = []
        for a in gen:
          _a = a.tostring()
          for b in ops:
            #if bracket(a, b):
            if cbracket(_a, b.tostring()):
                c = (a+b)%2
                s = c.tostring()
                if s not in found:
                    found.add(s)
                    new.append(c)
        if not new:
            break
        gen.extend(new)
        if argv.verbose:
            print len(gen),
            sys.stdout.flush()
    if argv.verbose:
        print
    return gen

closure = find_ideal



def test_model():

    Gx, Gz, Hx, Hz = models.build()
    model = models.build_model(Gx, Gz, Hx, Hz)

    Rx, Rz = model.Rx, model.Rz
    Rxt = Rx.transpose()
    Rzt = Rz.transpose()

    Px, Pz = model.Px, model.Pz
    Pxt = Px.transpose()
    Pzt = Pz.transpose()

    r, n = Rx.shape

    #print shortstrx(Rx, Rz)
    print "Gx:", len(Gx)
    print "r =", len(Rx)

    ops = []
    found = set()
    gops = []
    for gx in Gx:
        #rx = dot2(Px, gx)
        #rx = dot2(gx, PxtRzt)
        rx = dot2(gx, Rzt)
        #print rx, dot2(gx, PxtRzt)
        assert rx.sum()
        rx = mkop(rx, None)
        s = rx.tostring()
        if s not in found:
            found.add(s)
            ops.append(rx)
            gops.append(rx)

    cartan = []
    for gz in Gz:
        #rz = dot2(Pz, gz)
        #rz = dot2(gz, PztRxt)
        rz = dot2(gz, Rxt)
        assert rz.sum()
        rz = mkop(None, rz)
        s = rz.tostring()
        if s not in found:
            found.add(s)
            ops.append(rz)
            cartan.append(rz)

    #for op in ops:
    #    print op
    #print "cartan:", len(cartan)

    if argv.closure:
        ops = closure(ops)
        print "algebra dimension:", len(ops)

    if argv.render_ideals:
        model = gauge.make(Gx, Gz, Hx, Hz)

        found = set()
        i = 0
        for gx in Gx:
            #rx = dot2(gx, Rzt)
            gx = dot2(gx, Pxt)
            s = gx.tostring()
            if s in found:
                continue
            found.add(s)
            idxs = numpy.where(gx)[0]
            model.render(show_idxs=idxs)
            i += 1
            if i%6==0:
                model.newline()
        model.save("pic-gcolor-gauge.pdf")

        remain = list(gops)
        i = 0
        while remain:
            #print "remain:", len(remain)
            op = remain.pop(0)
            ideal = find_ideal([op], ops)
            print "ideal:", len(ideal)
            count = 0
            s_ideal = set(str(op) for op in ideal)

            for op in gops:
                if str(op) in s_ideal:
                    rx = get_xop(op)
                    gx = dot2(rx, Rx)
                    print "   ", shortstr(gx)
                    idxs = numpy.where(gx)[0]
                    model.render(show_idxs=idxs)

            #model.save("pic-ideal-%d.pdf"%i)
            model.newline()
            i += 1

            print "count:", len([1 for op in gops if str(op) in s_ideal])
            print
            ideal = set(op.tostring() for op in ideal)
            remain = [op for op in remain if not op.tostring() in ideal]
        model.save("pic-gcolor-ideals.pdf")

        return

    if argv.ideals:
        found = set()
        i = 0
        for gx in Gx:
            #rx = dot2(gx, Rzt)
            gx = dot2(gx, Pxt)
            s = gx.tostring()
            if s in found:
                continue
            found.add(s)

        nh = 0
        remain = list(gops)
        i = 0
        while remain:
            #print "remain:", len(remain)
            op = remain.pop(0)
            ideal = find_ideal([op], ops)
            print "ideal:", len(ideal)
            nh += len([op for op in ideal if is_zop(op)])
            count = 0
            s_ideal = set(str(op) for op in ideal)

            gxs = []
            for gx in Gx:
                rx = dot2(gx, Rzt)
                rx = mkop(rx, None)
                if str(rx) in s_ideal:
                    #rx = get_xop(op)
                    #gx = dot2(rx, Rx)
                    gxs.append(rx)
            gzs = []
            for gz in Gz:
                rz = dot2(gz, Rxt)
                rz = mkop(rz, None)
                if str(rz) in s_ideal:
                    #rz = get_zop(op)
                    #gz = dot2(rz, Rz)
                    gzs.append(rz)

            if argv.show:
                gxs = array2(gxs)
                gzs = array2(gzs)
                print "Gx:"
                print shortstrx(gxs)
                print "Gz:"
                print shortstrx(gzs)
                A = dot2(gxs, gzs.transpose())
                #print shortstrx(gxs, gzs, A)
                print "A.transpose():"
                print shortstr(A.transpose())

            ideal = set(op.tostring() for op in ideal)
            remain = [op for op in remain if not op.tostring() in ideal]

        print "cartan:", nh
        return


    return

    lookup = {}
    for i, op in enumerate(ops):
        lookup[op.tostring()] = i

    N = len(ops)

#    graph = nx.Graph()
#    for i in range(N):
#        graph.add_node(i)
#    for i, A in enumerate(ops):
#      for j, B in enumerate(ops):
#        if bracket(A, B)==0:
#            continue
#        C = (A+B)%2
#        k = lookup[C.tostring()]
#        graph.add_edge(i, k)
#        graph.add_edge(j, k)
#    equs = nx.connected_components(graph)
#    print "ideals:", len(equs), [len(equ) for equ in equs]

    if argv.stop2:
        return

    graph = nx.Graph()
    for i in range(N):
        graph.add_node(i)

    H = []
    for z in cartan:
        A = zeros2(N, N)
        for i, op in enumerate(ops):
            if is_zop(op):
                continue
            c = bracket(z, op)
            if c==0:
                continue
            op1 = (z+op)%2
            j = lookup[op1.tostring()]
            #print "%s->%s" % (i, j),
            A[j, i] = 1
            graph.add_edge(j, i)
        #print
        #print shortstr(A)
        #print
        H.append(A)
    
    for A in H:
      for B in H:
        assert numpy.allclose(numpy.dot(A, B), numpy.dot(B, A))

    equs = nx.connected_components(graph)
    print "orbits:", len(equs), [len(equ) for equ in equs]
    trivial = len([equ for equ in equs if len(equ)==1])
    print "trivial:", trivial, "non-trivial", len(equs)-trivial

    #for irrep in genidx((2,)*r):
    #    print "irrep:", irrep

    return

    r, n = Rx.shape
    N = 2**r
    gz = len(Gz)

    RR = dot2(Gz, Rx.transpose())
    PxtRzt = dot2(Px.transpose(), Rzt)

    if N<=1024:
        H = numpy.zeros((N, N))
    else:
        H = None
    A = {}
    U = []

    basis = []
    lookup = {}
    for i, v in enumerate(genidx((2,)*r)):
        v = array2(v)
        lookup[v.tostring()] = i
        basis.append(v)

    ops = []

    # zops
    for gz in Gz:
        elems = {}
        for i, v in enumerate(basis):
            bit = dot2(gz, Rx.transpose(), v)
            elems[(i, i)] = 1 - 2*bit # send 0,1 -> +1,-1

    # xops
    for gx in Gx:
        elems = {}
        for i, v in enumerate(basis):
            u = (v+dot2(gx, PxtRzt))%2
            j = lookup[u.tostring()]
            elems[j, i] = 1
        for (i, j) in elems:
            assert elems[i, j] == elems[j, i]





from argv import Argv

argv = Argv()

if __name__ == "__main__":

    fn = argv.next()
    if argv.profile:
        import cProfile as profile
        profile.run("%s()"%fn)

    else:
        fn = eval(fn)
        fn()


